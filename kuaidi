#!/usr/bin/env ruby
# coding: utf-8
#Description: 通过kuaidi100查询快递

require 'open-uri'
require 'json'

COMPANY_FILE = 'company.json'
SAVE_FILE = 'query.json'

USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:41.0) Gecko/20100101 Firefox/41.0'

# opens a url or a file and convert result to json
def json_open( uri )
  opts = uri =~ /^http/ ? { "User-Agent" => USER_AGENT, "Referer" => "http://www.kuaidi100.com" } : { }
  JSON.parse( open( uri, opts).read.force_encoding('utf-8'), :symbolize_names => true)
end

$company_list = []
if File.file? COMPANY_FILE
  $company_list = json_open COMPANY_FILE
end

def record_query(save_file, package, detail)
  begin
    saves = json_open save_file
  rescue
    saves = {}
  end
  saves[package] = {
    :company => decode_company(detail[:com]),
    :code => detail[:com],
    :last_query => Time.now.to_s,
    :status  => detail[:data] ? detail[:data][0] : nil
  }
  # delete older then 30 day records
  day = 24*3600
  saves = saves.delete_if {|_,v|
    query_time_delta = Time.now - Time.parse(v[:last_query])
    query_time_delta > 30*day or ( query_time_delta > 3*day and not v[:status] )
  }
  # delete partial tracking numbers
  numbers = saves.keys
  partial_keys = numbers.select{|k| numbers.any?{|i| i.to_s != k.to_s and i.to_s.include? k.to_s } }
  partial_keys.each{|k| saves.delete(k) }
  # delete the ones that completes to "clean"
  saves.delete_if{|k, v| "clean".include? k.to_s }

  open(save_file, 'w') {|f| f.puts saves.to_json}
end

def company_code(package_no)
  url = 'http://www.kuaidi100.com/autonumber/auto?num=' + package_no
  res = json_open( url )
  res = res.sort_by{|i| i[:noCount] }
  res.empty? ? nil : res.last[:comCode]
end

def kuaidi_status(package_no, com_code = nil)
  com_code ||= company_code(package_no)
  return  nil   unless com_code
  detail_url     = "http://www.kuaidi100.com/query?type=#{com_code}&postid=#{package_no}&id=1&valicode=&temp=0.08001715072286408"
  json_open detail_url
end

def format_status_record(record, color = "\e[37m")
  time = record[:time]
  context = record[:context].gsub(/\s+/, ' ')
  rec = time + '   ' + context
  color.to_s.empty? ? rec : color + rec + "\e[m"
end

def format_screen_detail(detail)
  p detail if $DEBUG
  if detail[:message] != 'ok'
    puts detail[:message]
    return
  end
  puts "\e[32;1m" + detail[:com] + "\t\e[31;1m" + ARGV.first + "\e[m\n"
  data = detail[:data].reverse
  data[0..-2].each {|i| puts format_status_record(i) }
  format_status_record(data.last, "\e[33;1m")
end

def format_detail(detail, output)
  send("format_#{output}_detail", detail)
end

def decode_company(code)
  if com = $company_list.find{|i| i[:code] == code }
    return com[:companyname]
  end
  code
end

def saved_pacakge_detail(package, attr)
  $saves ||= File.file?(SAVE_FILE) ? json_open(SAVE_FILE) : {}
  $saves[package] ? $saves[package][attr.to_s] : nil
end

if __FILE__==$0
  require 'optparse'

  options = {}
  OptionParser.new do |opts|
    opts.banner = "用法: #{$0} [options] <STRING>"
    opts.on('-s','--short','只显示最后结果') { options[:short] = true }
    options[:output] = :screen
  end.parse!

  abort "请输入快递号： #{$0} <快递单号>"  if  ARGV.empty?

  package = ARGV.first

  detail = kuaidi_status(package, saved_pacakge_detail(package, :code))

  detail ||= {:status => 'error', :message => "没找到有关快递单 #{package} 的信息"}

  if options[:short]
    detail[:data] = detail[:data][0..0]
  end

  puts format_detail(detail, options[:output])
end
